unit main;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, Contnrs, Menus, StdCtrls, ComCtrls, Math, ExtCtrls, Grids,
  ValEdit, Buttons, commctrl;

type
  TForm1 = class(TForm)
    OpenDialog1: TOpenDialog;
    MainMenu1: TMainMenu;
    N1: TMenuItem;
    N2: TMenuItem;
    N3: TMenuItem;
    Button1: TButton;
    Button2: TButton;
    N4: TMenuItem;
    N5: TMenuItem;
    BTL1: TMenuItem;
    CadWork1: TMenuItem;
    OpenDialog2: TOpenDialog;
    N6: TMenuItem;
    ListView1: TListView;
    SaveDialog1: TSaveDialog;
    N7: TMenuItem;
    N8: TMenuItem;
    Button3: TButton;
    Edit3: TEdit;
    Label5: TLabel;
    Memo1: TMemo;
    N9: TMenuItem;
    ListView2: TListView;
    BitBtn1: TBitBtn;
    BitBtn2: TBitBtn;
    GroupBox2: TGroupBox;
    N10: TMenuItem;
    Label1: TLabel;
    Label2: TLabel;
    Edit1: TEdit;
    N11: TMenuItem;
    N12: TMenuItem;
    N13: TMenuItem;
    N14: TMenuItem;
    N15: TMenuItem;
    N16: TMenuItem;
    N17: TMenuItem;
    N18: TMenuItem;
    N19: TMenuItem;
    N20: TMenuItem;
    N21: TMenuItem;
    Button4: TButton;
    N22: TMenuItem;
    N23: TMenuItem;
    N24: TMenuItem;
    N25: TMenuItem;
    N26: TMenuItem;
    N27: TMenuItem;
    N28: TMenuItem;
    CheckBox1: TCheckBox;
    N29: TMenuItem;
    N30: TMenuItem;
    SaveDialog2: TSaveDialog;
    procedure N3Click(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure N2Click(Sender: TObject);
    procedure Button1Click(Sender: TObject);
    procedure N5Click(Sender: TObject);
    procedure BTL1Click(Sender: TObject);
    procedure CadWork1Click(Sender: TObject);
    procedure N6Click(Sender: TObject);
    procedure listprog;
    procedure N7Click(Sender: TObject);
    procedure N8Click(Sender: TObject);
    procedure Button3Click(Sender: TObject);
    procedure N9Click(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure BitBtn2Click(Sender: TObject);
    procedure BitBtn1Click(Sender: TObject);
    procedure readlong;
    procedure FormCloseQuery(Sender: TObject; var CanClose: Boolean);
    procedure N10Click(Sender: TObject);
    procedure ListView2MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Edit1KeyPress(Sender: TObject; var Key: Char);
    procedure N12Click(Sender: TObject);
    procedure N14Click(Sender: TObject);
    procedure N15Click(Sender: TObject);
    procedure N16Click(Sender: TObject);
    procedure N17Click(Sender: TObject);
    procedure N18Click(Sender: TObject);
    procedure N19Click(Sender: TObject);
    procedure N21Click(Sender: TObject);
    procedure Button4Click(Sender: TObject);
    procedure N22Click(Sender: TObject);
    procedure N23Click(Sender: TObject);
    procedure N25Click(Sender: TObject);
    procedure N26Click(Sender: TObject);
    procedure perestavka(cases:byte;polubrus:boolean);
    procedure N27Click(Sender: TObject);
    procedure N28Click(Sender: TObject);
    procedure CheckBox1Click(Sender: TObject);
    procedure N29Click(Sender: TObject);
    procedure N30Click(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

  Tprogs = class        //класс описывающий программу зарезки
    idf:integer;        //ИД - порядковый номер программы из файла
    col:integer;        //количество изделий в программе
    idprv:integer;      //номер производства
    long:integer;       //длинна изделия
    zg:integer;         //номер заготовки            
    comment:string;     //комментарий из программы
    idcnststr:string;   //номера сборки в строке с файла спецификации
    data:TStringList;   //текст программы
    optilong:integer;   //длинна заготовки
    h:integer;          //высота бруса
    sh:integer;         //ширина бруса
    sorted:boolean;     //признак отсортированности операций
    obrs:TObjectList;   //список обработок
    procedure newh(nn:extended); //задаёт новую высоту бруса
    procedure reprog;   //обновляет текст программы копирую его из обработок
    //переставляет местами резку чашек сначала бок, потом верх
    procedure perestanovka;
    //переставляет местами резку чашек кадворк
    function perestanovkaCadWork(aaax:byte;bbbx:boolean):integer;
    //меняет сторону отпиливания с 1 на 3
    procedure changesidecut;
    //уменьшает глубину всех сверлений до значения параметра
    function reducedrill(newdepth:integer):boolean;
    //убирает ненужный пропил, возвращает количество удалённых операций
    function removebadcut:integer;

  end;

  Tobrs = class //текущие обработки в программе
    data:TStringList; //данные операции
    opkey:integer;    //код операции
    side:integer;     //сторона операции
    opgr:integer;     //группа операции
    p:array[1..21] of integer; //массив параметров
    //процедура обновления кода операции в зависимости от изменения параметров
    procedure newparam;
    //процедура обновления кода типа операции если он изменился
    procedure newopparam;
  end;

  TBtl = class          //класс загружаемого btl файла
    header:TStringList; //заголовок загружаемого btl файла
    progs:TObjectList;  //список программ загружаемого btl файла
    //конструктор парсит файл и создаёт готовый объект с заполненными полями
    constructor Create(filename:TFileName);  //имя загружаемого btl файла
    //функция парсит файл спецификации и подгружает номера сборки в объект
    function attachCADWorkSpec(filename:TFileName):boolean;
    //процедура уникализирует программы по номерам сборки или просто создаёт
    //копии программ, но одно изделие - одна программа
    procedure prepare;
    //запись конечного файла
    procedure writeprog(filename:TFileName);
    //процедура оптимизации
    //процедура пересчёта номеров BTl файла
    procedure nprz(venci:integer);
    //собственно процедура оптимизации
    procedure optimize(a:TObjectList;rez:integer);
    //процедура частичного сохранения
    procedure writeXprog(ax:integer;filename:TFileName);
    //процедура разбора файла, аналогичная конструктору для добавления файла. 
    procedure load(filename:TFileName);
  end;

  //класс процедуры оптимизации
  Topt = class
    id:integer;
    long:integer;
    idbrev:integer;
    ostatok:integer;
    optilong:integer;
  end;

  //класс процедуры оптимизации
  Tolong = class
    l:integer;        //текущая длинна
    col:integer;      //сколько раскроено заготовок
    opticol:integer;  //сколько раскраивать заготовок
  end;

  //класс процедуры оптимизации
  TKart = class
    ostatok:integer;    //остаток
    optilong:integer;   //длинна заготовки для текущего остатка
    inl:TObjectList;    //входной список изделий
    oul:TObjectList;    //выходной список изделий
  end;

var
  Form1: TForm1;
  Btl:TBtl;
  Sub:integer;
  Item:TListItem;

implementation

uses prosmotr, BTLheader, addlong, saveX, secnew, help, print, drillchange;

{$R *.dfm}

/////////////TProgs/////////////////////////////////////////////
////уменьшает глубину всех сверлений до значения параметра
function Tprogs.reducedrill(newdepth:integer):boolean;
var recalc,recalcop,recalcopp:boolean;
    i:integer;
begin
  Result:=false;
  //проверяем есть ли список операций и есть ли операции
  if assigned(obrs) then if obrs.Count>0 then begin
    //хотя бы одна операция пересчитана
    recalc:=false;
    //пробегаем все операции
    for i:=0 to obrs.Count-1 do begin
      //операция не пересчитывалась
      recalcop:=false;
      recalcopp:=false;
      //сверление, drilling по стороне 3 или стороне 1, с углами 90°
      //и глубиной более newdepth
      if (Tobrs(obrs[i]).opkey=40) and ((Tobrs(obrs[i]).opgr=3) or
      (Tobrs(obrs[i]).opgr=4)) and (Tobrs(obrs[i]).p[3]=0) and
      (Tobrs(obrs[i]).p[6]=900) and (Tobrs(obrs[i]).p[7]=900) and
      ((Tobrs(obrs[i]).side=3) or (Tobrs(obrs[i]).side=1)) and
      (Tobrs(obrs[i]).p[11]>(newdepth*10)) then begin
         Tobrs(obrs[i]).p[11]:=newdepth*10;
         //если сторона сверления 1, то меняем её на 3
         if Tobrs(obrs[i]).side=1 then begin
           Tobrs(obrs[i]).side:=3;
           recalcopp:=true;
         end;
         recalcop:=true;
      end;
      if recalcop then begin recalc:=true; Tobrs(obrs[i]).newparam; end;
      if recalcopp then begin recalc:=true; Tobrs(obrs[i]).newopparam; end;
    end;
    if recalc then begin Result:=true; reprog; end;
  end;
end;

/////////////////убрать пропил//////////////////////////////////
function TProgs.removebadcut:integer;
var recalc,recalcop:boolean;
    i:integer;
begin
  /////////////////////////////////
  Result:=0;
  //проверяем есть ли список операций и есть ли операции
  if assigned(obrs) then if obrs.Count>0 then begin
    //хотя бы одна операция пересчитана
    recalc:=false;
    //пробегаем все операции
    i:=0;
    repeat
      //операция не пересчитывалась
      recalcop:=false;
      //сверление, drilling по стороне 3 или стороне 1, с углами 90°
      //и глубиной более newdepth
      if (Tobrs(obrs[i]).opkey=16) and ((Tobrs(obrs[i]).opgr=4) or
      (Tobrs(obrs[i]).side=3) or (Tobrs(obrs[i]).side=1)) then begin
         obrs.Delete(i);
         Result:=Result+1;
         recalcop:=true;
      end;
      if recalcop then recalc:=true;
      if not recalcop then inc(i);
    until i>(obrs.Count-1);
    if recalc then reprog;
  end;

end;

////////////////////////////////////////////////////////////////

procedure Tprogs.newh(nn:extended);
var old_h,i,j,hdx,nh:integer;
    s,s1,s2:string;
    recalc,recalcall:boolean;
begin
  nh:=round(nn*10);
  old_h:=h; //запоминаем старую высоту
  //вычислияем приращение высоты
  hdx:=nh-h;
  //изменяем выстоту в свойствах программы-объекта и в тексте программы
  h:=nh;
  for i:=0 to data.Count-1 do begin
    s:=data.Strings[i];
    if pos('BP',s)=1 then
      if pos('P02',s)<>0 then begin
        s2:=copy(s,pos('P02',s),12);
        s1:=inttostr(nh);
        if length(s1)<8 then for j:=length(s1) to 7 do s1:='0'+s1;
        s1:='P02:'+s1;
        s:=StringReplace(s,s2,s1,[]);
        data.Strings[i]:=s;
        break;
      end;
  end;
  //пересчёт операций
  //хотя бы одна операция не изменялась
  recalcall:=false;
  //перебираем все операции
  for i:=0 to obrs.Count-1 do begin
    //операция не пересчитана
    recalc:=false;
    //////////начало условий операций пересчёта////////////////////////
    //сверление, drilling по стороне 3 или стороне 1, с углами 90°
    if (Tobrs(obrs[i]).opkey=40) and ((Tobrs(obrs[i]).opgr=3) or
      (Tobrs(obrs[i]).opgr=4)) and (Tobrs(obrs[i]).p[3]=0) and
      (Tobrs(obrs[i]).p[6]=900) and (Tobrs(obrs[i]).p[7]=900) and
      ((Tobrs(obrs[i]).side=3) or (Tobrs(obrs[i]).side=1)) then begin
        //операция пересчитана
        recalc:=true;
        //увеличиваем глубину сверления на hdx
        Tobrs(obrs[i]).p[11]:=Tobrs(obrs[i]).p[11]+hdx;
    end;
    //врубка в полдерева, Lap Joint, прямые врубки по сторонам 2 и 4, угол 7=90°
    if (Tobrs(obrs[i]).opkey=30) and ((Tobrs(obrs[i]).opgr=3) or
      (Tobrs(obrs[i]).opgr=4)) and (Tobrs(obrs[i]).p[7]=900) and
      ((Tobrs(obrs[i]).side=2) or (Tobrs(obrs[i]).side=4)) then begin
        //операция пересчитана
        recalc:=true;
        //увеличиваем глубину прореза на hdx
        Tobrs(obrs[i]).p[14]:=Tobrs(obrs[i]).p[14]+hdx;
    end;
    //врубка в полдерева, Lap Joint, прямая врубка по стороне 3, угол 90°
    if (Tobrs(obrs[i]).opkey=30) and ((Tobrs(obrs[i]).opgr=3) or
      (Tobrs(obrs[i]).opgr=4)) and
      (Tobrs(obrs[i]).p[6]=900) and (Tobrs(obrs[i]).p[7]=900) and
      (Tobrs(obrs[i]).side=3) then begin
        //операция пересчитана
        recalc:=true;
        //увеличиваем глубину врубки под прям. углом к оп. поверхн. на hdx
        Tobrs(obrs[i]).p[11]:=Tobrs(obrs[i]).p[11]+hdx;
    end;
  {  //врубка в полдерева, Lap Joint, прямая врубка по стороне 1, угол 90°
    if (Tobrs(obrs[i]).opkey=30) and ((Tobrs(obrs[i]).opgr=3) or
      (Tobrs(obrs[i]).opgr=4)) and
      (Tobrs(obrs[i]).p[6]=900) and (Tobrs(obrs[i]).p[7]=900) and
      (Tobrs(obrs[i]).side=1) then begin
        //операция пересчитана
        recalc:=true;
        //увеличиваем глубину врубки под прям. углом к оп. поверхн. на hdx
        Tobrs(obrs[i]).p[11]:=Tobrs(obrs[i]).p[11]+hdx;
    end;   }
    //обшивка свеса крыши, Seathing Cut, по стороне 3
    if (Tobrs(obrs[i]).opkey=34) and ((Tobrs(obrs[i]).opgr=3) or
      (Tobrs(obrs[i]).opgr=4)) and (Tobrs(obrs[i]).side=3) then begin
        //операция пересчитана
        recalc:=true;
        //увеличиваем глубину врубки под прям. углом к оп. поверхн. на hdx
        Tobrs(obrs[i]).p[11]:=Tobrs(obrs[i]).p[11]+hdx;
    end;
    //ласточкин хвост прямой, Mortise Front, углы p7 и p8 90°, сторона 3
    if (Tobrs(obrs[i]).opkey=51) and ((Tobrs(obrs[i]).opgr=3) or
      (Tobrs(obrs[i]).opgr=4)) and (Tobrs(obrs[i]).p[3]=0) and
      (Tobrs(obrs[i]).p[7]=900) and
      (Tobrs(obrs[i]).p[8]=900) and (Tobrs(obrs[i]).side=3) then begin
        //операция пересчитана
        recalc:=true;
        //увеличиваем глубину прореза на hdx
        Tobrs(obrs[i]).p[14]:=Tobrs(obrs[i]).p[14]+hdx;
    end;
    //ласточкин хвост прямой, Mortise Front, угол р8 90°, сторона 2,4
    if (Tobrs(obrs[i]).opkey=51) and ((Tobrs(obrs[i]).opgr=3) or
      (Tobrs(obrs[i]).opgr=4)) and (Tobrs(obrs[i]).p[3]=0) and
      (Tobrs(obrs[i]).p[6]=0) and (Tobrs(obrs[i]).p[7]=0) and
      (Tobrs(obrs[i]).p[8]=900) and
      ((Tobrs(obrs[i]).side=2) or (Tobrs(obrs[i]).side=4)) then begin
        //операция пересчитана
        recalc:=true;
        //увеличиваем глубину прореза на hdx
        //если угол Р08 не составной
        if Tobrs(obrs[i]).p[21]<>8 then 
        Tobrs(obrs[i]).p[14]:=Tobrs(obrs[i]).p[14]+hdx;
    end;   
    //торцевой паз, Front Slot все углы 90°, сторона 1 или 3
    if (Tobrs(obrs[i]).opkey=17) and ((Tobrs(obrs[i]).opgr=3) or
      (Tobrs(obrs[i]).opgr=4)) and
      (Tobrs(obrs[i]).p[6]=900) and (Tobrs(obrs[i]).p[7]=900) and
      (Tobrs(obrs[i]).p[8]=900) and
      ((Tobrs(obrs[i]).side=1) or (Tobrs(obrs[i]).side=3)) then begin
        //операция пересчитана
        recalc:=true;
        //увеличиваем глубину прореза на hdx
        Tobrs(obrs[i]).p[12]:=Tobrs(obrs[i]).p[12]+hdx;
        //смещаем опорную точку на hdx/2
        Tobrs(obrs[i]).p[3]:=Tobrs(obrs[i]).p[3]+(hdx div 2);
    end;
    //Паз/шпутн, Notch/Rabbet, углов не имеет, сторона 4 или 2
    if (Tobrs(obrs[i]).opkey=32) and                            //операция
      ((Tobrs(obrs[i]).opgr=3) or (Tobrs(obrs[i]).opgr=4)) and  //группа операции
      (Tobrs(obrs[i]).side=2) then begin  //сторона
        //операция пересчитана
        recalc:=true;
        //смещаем опорную точку на +hdx
        Tobrs(obrs[i]).p[2]:=Tobrs(obrs[i]).p[2]+hdx;
    end;
    //обработка "фронтонов"
    //обработка "фронтонов" конец бревна
    if (TObrs(obrs[i]).opkey=10) and
         ((TObrs(obrs[i]).opgr=1) or (TObrs(obrs[i]).opgr=2)) and
         (TObrs(obrs[i]).side=1) and (TObrs(obrs[i]).p[7]<>900) and
         (abs( TObrs(obrs[i]).p[1] -
         Round(long-(old_h*tan(((Tobrs(obrs[i]).p[7]-900)/10)*(PI/180))))
         )<=9)
         then begin
           recalc:=true;
           TObrs(obrs[i]).side:=2;
           TObrs(obrs[i]).p[1]:=long;
           TObrs(obrs[i]).p[6]:=1800-TObrs(obrs[i]).p[7];
           TObrs(obrs[i]).p[7]:=900;
           TObrs(obrs[i]).newopparam;
    end;
    //обработка "фронтонов"
    //обработка "фронтонов" начало бревна
    if (TObrs(obrs[i]).opkey=10) and
         ((TObrs(obrs[i]).opgr=1) or (TObrs(obrs[i]).opgr=2)) and
         (TObrs(obrs[i]).side=1) and (TObrs(obrs[i]).p[7]<>900) and
         (abs( TObrs(obrs[i]).p[1] -
         Round(old_h*tan(((Tobrs(obrs[i]).p[7]-900)/10)*(PI/180)))
         )<=9)
         then begin
           recalc:=true;
           TObrs(obrs[i]).side:=2;
           TObrs(obrs[i]).p[1]:=0;
           TObrs(obrs[i]).p[6]:=1800-TObrs(obrs[i]).p[7];
           TObrs(obrs[i]).p[7]:=900;
           TObrs(obrs[i]).newopparam;
    end;
    ///////////конец условий пересчёта/////////////////////////////////
    //если операция была пересчитана обновляем текст-код операции
    if recalc then begin recalcall:=true; Tobrs(obrs[i]).newparam; end;
  end;
  if recalcall then reprog;
end;

//вспомогательная функция класса TProgs процедуры changesidecut
function sortList8(p1,p2:pointer):integer; //служебная функция optimize
begin
  //сортировка по возрастанию
  Result:=sign(TObrs(p1).p[1]-TObrs(p2).p[1]);
end;

//меняет сторону отпиливания с 1 на 3
procedure TProgs.changesidecut;
var recalcop,recalcall,recalc:boolean;
    i:integer;
begin
  //проверяем есть ли список операций и есть ли операции
  if assigned(obrs) then if obrs.Count>0 then begin
    //пробегаем все операции
    for i:=0 to obrs.Count-1 do begin
      //операция не пересчитывалась
      recalcop:=false;
      recalc:=false;
      //торцевой паз замена стороны 1 на сторону 3
      if (TObrs(obrs[i]).opkey=17) and
         ((TObrs(obrs[i]).opgr=3) or (TObrs(obrs[i]).opgr=4)) and
         (TObrs(obrs[i]).side=1) then begin
           //операция пересчитана
           recalcop:=true;
           TObrs(obrs[i]).side:=3;
      end;
      //врубка в полдерева, Lap Joint избавляемся от одиночного убирания фрагмента
      //ГРУППА 4, с заднего торца, стороны 2 и 4
      if (TObrs(obrs[i]).opkey=30) and (TObrs(obrs[i]).opgr=4) and
         ((TObrs(obrs[i]).side=2) or (TObrs(obrs[i]).side=4)) and
         (TObrs(obrs[i]).p[6]=900) and (TObrs(obrs[i]).p[7]=900) and
         (TObrs(obrs[i]).p[14]=h) and
         (TObrs(obrs[i]).p[1]+TObrs(obrs[i]).p[12]=long) then begin
           recalc:=true;
           TObrs(obrs[i]).p[12]:=TObrs(obrs[i]).p[12]-1;
      end;
      //врубка в полдерева, Lap Joint избавляемся от одиночного убирания фрагмента
      //ГРУППА 4, с переднего торца, стороны 2 и 4
      if (TObrs(obrs[i]).opkey=30) and (TObrs(obrs[i]).opgr=4) and
         ((TObrs(obrs[i]).side=2) or (TObrs(obrs[i]).side=4)) and
         (TObrs(obrs[i]).p[6]=900) and (TObrs(obrs[i]).p[7]=900) and
         (TObrs(obrs[i]).p[14]=h) and
         (TObrs(obrs[i]).p[1]=0) then begin
           recalc:=true;
           TObrs(obrs[i]).p[1]:=TObrs(obrs[i]).p[1]+1;
      end;
      //врубка в полдерева, Lap Joint избавляемся от одиночного убирания фрагмента
      //ГРУППА 4, с заднего торца, стороны 1 и 3
      if (TObrs(obrs[i]).opkey=30) and (TObrs(obrs[i]).opgr=4) and
         ((TObrs(obrs[i]).side=1) or (TObrs(obrs[i]).side=3)) and
         (TObrs(obrs[i]).p[6]=900) and (TObrs(obrs[i]).p[7]=900) and
         (TObrs(obrs[i]).p[14]=sh) and
         (TObrs(obrs[i]).p[1]+TObrs(obrs[i]).p[12]=long) then begin
           recalc:=true;
           TObrs(obrs[i]).p[12]:=TObrs(obrs[i]).p[12]-1;
      end;
      //врубка в полдерева, Lap Joint избавляемся от одиночного убирания фрагмента
      //ГРУППА 4, с переднего торца, стороны 1 и 3
      if (TObrs(obrs[i]).opkey=30) and (TObrs(obrs[i]).opgr=4) and
         ((TObrs(obrs[i]).side=1) or (TObrs(obrs[i]).side=3)) and
         (TObrs(obrs[i]).p[6]=900) and (TObrs(obrs[i]).p[7]=900) and
         (TObrs(obrs[i]).p[14]=sh) and
         (TObrs(obrs[i]).p[1]=0) then begin
           recalc:=true;
           TObrs(obrs[i]).p[1]:=TObrs(obrs[i]).p[1]+1;
      end;
      //врубка в полдерева, Lap Joint избавляемся от одиночного убирания фрагмента
      //*ГРУППА 3, с заднего торца, стороны 2 и 4
      if (TObrs(obrs[i]).opkey=30) and (TObrs(obrs[i]).opgr=3) and
         ((TObrs(obrs[i]).side=2) or (TObrs(obrs[i]).side=4)) and
         (TObrs(obrs[i]).p[6]=900) and (TObrs(obrs[i]).p[7]=900) and
         (TObrs(obrs[i]).p[14]=h) and
         (TObrs(obrs[i]).p[1]=TObrs(obrs[i]).p[12]) then begin
           recalc:=true;
           TObrs(obrs[i]).p[12]:=TObrs(obrs[i]).p[12]-1;
      end;
      //врубка в полдерева, Lap Joint избавляемся от одиночного убирания фрагмента
      //*ГРУППА 3, с переднего торца, стороны 2 и 4
      if (TObrs(obrs[i]).opkey=30) and (TObrs(obrs[i]).opgr=3) and
         ((TObrs(obrs[i]).side=2) or (TObrs(obrs[i]).side=4)) and
         (TObrs(obrs[i]).p[6]=900) and (TObrs(obrs[i]).p[7]=900) and
         (TObrs(obrs[i]).p[14]=h) and
         (TObrs(obrs[i]).p[1]=long) then begin
           recalc:=true;
           TObrs(obrs[i]).p[1]:=TObrs(obrs[i]).p[1]-1;
           TObrs(obrs[i]).p[12]:=TObrs(obrs[i]).p[12]-1;
      end;
      //врубка в полдерева, Lap Joint избавляемся от одиночного убирания фрагмента
      //*ГРУППА 3, с заднего торца, стороны 1 и 3
      if (TObrs(obrs[i]).opkey=30) and (TObrs(obrs[i]).opgr=3) and
         ((TObrs(obrs[i]).side=1) or (TObrs(obrs[i]).side=3)) and
         (TObrs(obrs[i]).p[6]=900) and (TObrs(obrs[i]).p[7]=900) and
         (TObrs(obrs[i]).p[14]=sh) and
         (TObrs(obrs[i]).p[1]=TObrs(obrs[i]).p[12]) then begin
           recalc:=true;
           TObrs(obrs[i]).p[12]:=TObrs(obrs[i]).p[12]-1;
      end;
      //врубка в полдерева, Lap Joint избавляемся от одиночного убирания фрагмента
      //*ГРУППА 3, с переднего торца, стороны 1 и 3
      if (TObrs(obrs[i]).opkey=30) and (TObrs(obrs[i]).opgr=3) and
         ((TObrs(obrs[i]).side=1) or (TObrs(obrs[i]).side=3)) and
         (TObrs(obrs[i]).p[6]=900) and (TObrs(obrs[i]).p[7]=900) and
         (TObrs(obrs[i]).p[14]=sh) and
         (TObrs(obrs[i]).p[1]=long) then begin
           recalc:=true;
           TObrs(obrs[i]).p[1]:=TObrs(obrs[i]).p[1]-1;
           TObrs(obrs[i]).p[12]:=TObrs(obrs[i]).p[12]-1;
      end;
      //врубка в полдерева под углом, Lap Joint с переднего торца, стороны 2 и 4
      //ГРУППА 3, избавляемся от одиночного убирания фрагмента
      if (TObrs(obrs[i]).opkey=30) and (TObrs(obrs[i]).opgr=3) and
         ((TObrs(obrs[i]).side=2) or (TObrs(obrs[i]).side=4)) and
         (TObrs(obrs[i]).p[6]<>900) and (TObrs(obrs[i]).p[7]=900) and
         (TObrs(obrs[i]).p[14]=h) and
         ((TObrs(obrs[i]).p[1]/10)<=
         SimpleRoundTo(
         ((TObrs(obrs[i]).p[12]/10))/
         (sin((180-(TObrs(obrs[i]).p[6]/10))*(PI/180))),-1))
          then begin
           recalc:=true;
           TObrs(obrs[i]).p[12]:=Round((TObrs(obrs[i]).p[1]-1)*
           sin((180-(TObrs(obrs[i]).p[6]/10))*(PI/180)));
      end;
      //операция пересчитывалась
      if recalcop then  TObrs(obrs[i]).newopparam;
      if recalc then TObrs(obrs[i]).newparam;
    end;
    //хотя бы одна операция пересчитывалась
    obrs.Sort(sortlist8);
    //устанавливаем признак отсортированности операций
    sorted:=true;
    reprog;
  end;
end;


//обновление данных основной программы при изменении данных операции
procedure TProgs.reprog;
var i,j:integer;
    temps:TStringList;
begin
  temps:=TStringList.Create;
  for i:=0 to data.Count-1 do
    if pos('KS',data.Strings[i])<>1 then begin
      if pos('BT',data.Strings[i])=1 then temps.Add('BT '+inttostr(idf)) else
        if pos('BN',data.Strings[i])=1 then temps.Add('BN '+comment) else
          temps.Add(data.Strings[i])
    end else break;
  for i:=0 to obrs.Count-1 do
    for j:=0 to Tobrs(obrs[i]).data.Count-1 do
      temps.Add(Tobrs(obrs[i]).data.Strings[j]);
  data.Clear;
  for i:=0 to temps.Count-1 do data.Add(temps.Strings[i]);
  temps.Free;    
end;

procedure Tprogs.perestanovka;
var i:integer;
begin
  //если операции существуют
  if assigned(obrs) then begin
    for i:=0 to obrs.Count-1 do begin
      //если номер операции 30, группы 3 или 4, а сторона операции 1 или 3
      if (TObrs(obrs[i]).opkey=30) and
      ((TObrs(obrs[i]).opgr=3) or (TObrs(obrs[i]).opgr=4)) and
      ((TObrs(obrs[i]).side=3) or (TObrs(obrs[i]).side=1)) then
        //проверяем следующую операцию если она есть
        if (i+1)<(obrs.Count-1) then
          if (TObrs(obrs[i+1]).opkey=30) and
          ((TObrs(obrs[i+1]).opgr=3) or (TObrs(obrs[i+1]).opgr=4)) and
          ((TObrs(obrs[i+1]).side=3) or (TObrs(obrs[i+1]).side=1)) then
            //проверяем дальше, только стороны другие
            if (i+2)<(obrs.Count-1) then
              if (TObrs(obrs[i+2]).opkey=30) and
              ((TObrs(obrs[i+2]).opgr=3) or (TObrs(obrs[i+2]).opgr=4)) and
              ((TObrs(obrs[i+2]).side=2) or (TObrs(obrs[i+2]).side=4)) then
                if (i+3)<(obrs.Count-1) then
                  if (TObrs(obrs[i+3]).opkey=30) and
                  ((TObrs(obrs[i+3]).opgr=3) or (TObrs(obrs[i+3]).opgr=4)) and
                  ((TObrs(obrs[i+3]).side=2) or (TObrs(obrs[i+3]).side=4)) then
                    //неврерная зарезка операций чашки
                    begin
                      obrs.Exchange(i,i+2);
                      obrs.Exchange(i+1,i+3);
                      reprog;
                      //break;
                    end;

    end;
  end;
end;

function TProgs.perestanovkaCadWork(aaax:byte;bbbx:boolean):integer;
var i,j,k,excl:integer;
    findch,half:boolean;
begin
  if assigned(obrs) then begin //проверка существования операций в программе
    Result:=0;
    i:=-1;
//    for i:=0 to obrs.Count-1 do begin //перебираем операции
    while i<(obrs.Count-1) do begin
      i:=i+1;
      findch:=false;
      //если номер операции 30, группы 3 или 4
      if (TObrs(obrs[i]).opkey=30) and
      ((TObrs(obrs[i]).opgr=3) or (TObrs(obrs[i]).opgr=4)) then
        //проверяем следующую операцию если она есть
        if (i+1)<(obrs.Count-1) then
          if (TObrs(obrs[i+1]).opkey=30) and
          ((TObrs(obrs[i+1]).opgr=3) or (TObrs(obrs[i+1]).opgr=4)) then
            //проверяем дальше
            if (i+2)<(obrs.Count-1) then
              if (TObrs(obrs[i+2]).opkey=30) and
              ((TObrs(obrs[i+2]).opgr=3) or (TObrs(obrs[i+2]).opgr=4)) then
                if not bbbx then begin
                  if ((i+3)<(obrs.Count-1)) then
                    if (TObrs(obrs[i+3]).opkey=30) and
                      ((TObrs(obrs[i+3]).opgr=3) or (TObrs(obrs[i+3]).opgr=4)) then
                       //чашка нашлась
                       findch:=true;
                  end else findch:=true;
      if findch then
            //дополнительное условие если чашки идут подряд
            if ((TObrs(obrs[i+1]).p[1]=TObrs(obrs[i+2]).p[1]) and
            (TObrs(obrs[i+2]).p[1]=TObrs(obrs[i+3]).p[1])) or (bbbx and
            (TObrs(obrs[i+1]).p[1]=TObrs(obrs[i+2]).p[1]))
             then
    begin
      //проверка на получашку
      k:=0;
      excl:=0;
      for j:=0 to 3 do if Tobrs(obrs[i+j]).opkey=30 then k:=k+1 else excl:=Tobrs(obrs[i+j]).side;
      //находим в чашке 1 сторону и ставим её на первое место.
      if aaax=1 then begin
        for j:=0 to 3 do
           if (Tobrs(obrs[i+j]).side=3) and (Tobrs(obrs[i+j]).opkey=30) and (Tobrs(obrs[i]).opkey=30)   and (excl<>3) then  //3
             obrs.Exchange(i,i+j);
        for j:=0 to 3 do
           if (Tobrs(obrs[i+j]).side=1) and (Tobrs(obrs[i+j]).opkey=30) and (Tobrs(obrs[i+1]).opkey=30) and (excl<>1) then  //1
             obrs.Exchange(i+1,i+j);
        for j:=0 to 3 do
           if (Tobrs(obrs[i+j]).side=2) and (Tobrs(obrs[i+j]).opkey=30) and (Tobrs(obrs[i+2]).opkey=30) and (excl<>2) then  //2
             obrs.Exchange(i+2,i+j);
        for j:=0 to 3 do
           if (Tobrs(obrs[i+j]).side=4) and (Tobrs(obrs[i+j]).opkey=30) and (Tobrs(obrs[i+3]).opkey=30) and (excl<>4) then  //4
             obrs.Exchange(i+3,i+j);
        reprog;
        inc(Result);
        i:=i+1;
      end;
      if aaax=2 then begin
        for j:=0 to 3 do
           if (Tobrs(obrs[i+j]).side=2) and (Tobrs(obrs[i+j]).opkey=30) and (Tobrs(obrs[i]).opkey=30)   and (excl<>2) then  //3
             obrs.Exchange(i,i+j);
        for j:=0 to 3 do
           if (Tobrs(obrs[i+j]).side=4) and (Tobrs(obrs[i+j]).opkey=30) and (Tobrs(obrs[i+1]).opkey=30) and (excl<>4) then  //1
             obrs.Exchange(i+1,i+j);
        for j:=0 to 3 do
           if (Tobrs(obrs[i+j]).side=3) and (Tobrs(obrs[i+j]).opkey=30) and (Tobrs(obrs[i+2]).opkey=30) and (excl<>3) then  //2
             obrs.Exchange(i+2,i+j);
        for j:=0 to 3 do
           if (Tobrs(obrs[i+j]).side=1) and (Tobrs(obrs[i+j]).opkey=30) and (Tobrs(obrs[i+3]).opkey=30) and (excl<>1) then  //4
             obrs.Exchange(i+3,i+j);
        reprog;
        inc(Result);
        i:=i+1;
      end;
    end;

    end;
  end;
end;

/////////////TObrs//////////////////////////////////////////////
procedure TObrs.newparam;
var i,j:integer;
    s,s1,s2:string;
begin
  s:='KP ';
  for i:=1 to 20 do
    if p[i]>=0 then begin
      s1:=inttostr(i);
      if length(s1)<2 then s1:='0'+s1;
      s1:='P'+s1+':';
      s2:=inttostr(p[i]);
      if p[21]=i then s2:='0000-'+s2;
      for j:=length(s2) to 7 do s2:='0'+s2;
      s:=s+s1+s2+' ';
    end;
  s:=trimright(s);
  if pos('KP',data.Strings[1])=1 then data.Strings[1]:=s;
end;

//изменение типа, группы или стороны операции
procedure TObrs.newopparam;
var s,s1,s2:string;
    i:integer;
begin
  s:=data.Strings[0];
  delete(s,1,11);
  s1:='KS ';
  s2:=inttostr(opgr);
  if length(s2)=1 then s1:=s1+s2+'-';
  s2:=inttostr(opkey);
  if length(s2)<3 then for i:=length(s2)+1 to 3 do s2:='0'+s2;
  if length(s2)=3 then s1:=s1+s2+'-';
  s2:=inttostr(side);
  if length(s2)=1 then s1:=s1+s2+' '+s;
  if pos('KS ',data.Strings[0])=1 then data.Strings[0]:=s1;
end;

/////////////TBtl///////////////////////////////////////////////
constructor TBtl.Create(filename:TFileName);
var f:textfile;
    s,s1,s2,s3:string;
    prog:TProgs;
    oprt,i:integer;
    obr:Tobrs;
    eop:boolean;
begin
  inherited Create;
  if filename<>'' then begin
    assignfile(f,filename);
    reset(f);
    readln(f,s);
    if ((pos('VN',s)=1) and (pos('BTL V5.0',s)<>0))// or (pos('BTL V1.0',s)<>0)
     then begin
      header:=TStringList.Create;
      //заполняем заголовок до тех пор, пока не найдена первая программа
      repeat
        header.Add(s);
        readln(f,s);
      until (pos('BT',s)=1) or eof(f);
      eop:=false;
      //если первая программа найдена создаём список программ
      //подтверждаем полное удаление объекта из памяти
      if pos('BT',s)=1 then progs:=TObjectList.Create(true);
      while not eof(f) do begin  //читаем файл полностью
        //читаем пока не нашли новую программу или файл не кончился
        repeat
          if pos('BT',s)=1 then begin  //мы нашли номер программы
            prog:=TProgs.Create;       //создаём объект программы
            prog.sorted:=false;        //операции программы не отсортированы
            prog.data:=TStringList.Create; //создаём список текста программы
            s1:=s;      //теперь работаем с s1
            oprt:=0;    //список операций = 0
            delete(s1,1,3);
            prog.idf:=strtoint(s1);    //номер закидываем в объект программы
            eop:=false;
          end;
          if pos('BN',s)=1 then begin //мы нашли строчку комментария программы
            s1:=s;
            delete(s1,1,3);
            if assigned(prog) then    //если программа создана
               prog.comment:=s1;      //кидаем в комментарий
          end;
          if pos('BP',s)=1 then begin //если строка с данными программы
            s1:=s;
            if pos('A:',s1)<>0 then begin  //ищем в строке количество проходов
              delete(s1,1,pos('A:',s1)+1);
              delete(s1,pos(' ',s1),length(s1)-pos(' ',s1)+1); //выделяем число
              if assigned(prog) then
                  prog.col:=strtoint(s1);  //число проходов
            end;
            s1:=s;                         //восстанавливаем строку
            if pos('P01',s1)<>0 then begin //ищем длинну
              delete(s1,1,pos('P01',s1)+3);
              delete(s1,pos(' ',s1),length(s1)-pos(' ',s1)+1);
              if assigned(prog) then
                  prog.long:=strtoint(s1);
            end;
            s1:=s;
            if pos('P02',s1)<>0 then begin  //ищем высоту бруса
              delete(s1,1,pos('P02',s1)+3);
              delete(s1,pos(' ',s1),length(s1)-pos(' ',s1)+1);
              if assigned(prog) then
                  prog.h:=strtoint(s1);
            end;
            s1:=s;
            if pos('P03',s1)<>0 then begin  //ищем ширину бруса
              delete(s1,1,pos('P03',s1)+3);
              delete(s1,pos(' ',s1),length(s1)-pos(' ',s1)+1);
              if assigned(prog) then
                  prog.sh:=strtoint(s1);
            end;
            s1:=s;
            if pos('P09',s1)<>0 then begin  //ищем номер производства
              delete(s1,1,pos('P09',s1)+3);
              delete(s1,pos(' ',s1),length(s1)-pos(' ',s1)+1);
              if assigned(prog) then
                  prog.idprv:=strtoint(s1);
            end;
          end;   //строка с данными распарсена
          //найдена операция
          if pos('KS',s)=1 then begin
            //если это первая операция в программе создаём список операций
            if oprt=0 then prog.obrs:=TObjectList.Create;
            oprt:=oprt+1;
            eop:=true; //найдена операция
            //создаём текущую операцию
            obr:=TObrs.Create;
            obr.data:=TStringList.Create;
            s1:=s;
            delete(s1,1,3);
            s1:=copy(s1,1,pos('-',s1)-1);
            obr.opgr:=strtoint(s1);
            s1:=s;
            delete(s1,1,pos('-',s1));
            s1:=copy(s1,1,pos('-',s1)-1);
            obr.opkey:=strtoint(s1);
            s1:=s;
            delete(s1,1,5);
            s1:=copy(s1,pos('-',s1)+1,1);
            obr.side:=strtoint(s1);
            obr.data.Add(s);
            //инициализация массива параметров с помощью отриц.чисел - пустое значение
            for i:=1 to 21 do obr.p[i]:=-1;
          end;
          if pos('KP',s)=1 then begin
            if oprt<>0 then begin
              s1:=s;
              delete(s1,1,3);
              repeat
                s2:=copy(s1,2,2); //индекс массива - он же номер параметра
                delete(s1,1,4);
                //значение параметра
                if length(s1)>8 then s3:=copy(s1,1,pos(' ',s1)-1)
                  else s3:=s1;
                if length(s1)>8 then delete(s1,1,pos(' ',s1)) else s1:='';
                //добавляем параметр в массив
                if pos('-',s3)<>0 then begin
                  delete(s3,pos('-',s3),1);
                  obr.p[21]:=strtoint(s2);
                end;
                obr.p[strtoint(s2)]:=strtoint(s3);
              until s1='';
              obr.data.Add(s);
            end;
          end;
          if pos('KF',s)=1 then begin
            if oprt<>0 then begin
              obr.data.Add(s);
            end;
          end;
          //добавление операции в  программу
          if (pos('KF FR',s)=1) and (oprt<>0) and assigned(prog.obrs) then begin
            prog.obrs.Add(obr);
            eop:=false; //операция добавлена
          end;
          //добавляем текущую прочитанную строку в блок данных
          if assigned(prog) then
                prog.data.Add(s);
          readln(f,s); //читаем новую строку
          //последняя строка данных
          if eof(f) then begin
            //добавим её к данным программы
            if assigned(prog) then prog.data.Add(s);
            //если в этой строке конец операции добавляем и операцию
            if (pos('KF',s)=1) and (oprt<>0) and assigned(prog.obrs) then
              prog.obrs.Add(obr);
          end;
          //если мы нашли новую программу или новую операцию, а старую не добавили
          if ((pos('BT',s)=1) or (pos('KS',s)=1)) and eop and assigned(prog.obrs) then begin
            prog.obrs.Add(obr);
            eop:=false;
          end;
        //если в прочитанной строке новая программа или конец файла в верхний цикл
        until (pos('BT',s)=1) or eof(f);
        //если есть список кидаем туда программу
        if assigned(progs) then
             progs.Add(prog);
      end;
    end else showmessage('Это не BTL-файл версии 5.0');
    closefile(f); //файл кончился, закрываем его
  end;
end;

function TBtl.attachCADWorkSpec(filename:TFileName):boolean;
var f:textfile;
    s:string;
    numpr,i,j:integer;
begin
  j:=0;
  if (filename<>'') or (assigned(progs)) then begin
    assignfile(f,filename);
    reset(f);
    readln(f,s);
    if pos('.lstm',s)<>0 then begin //проверка ключевого слова в файле
      //читаем файл до конца
      while not eof(f) do begin
        readln(f,s);  //читаем со второй строки
        s:=trimLeft(s); //удаляем левые пробелы
        //вырезаем строку слева до пробела и проверяем преобразуется
        //ли она в целое число, если да, то проверяем что оно не 0
        //если всё удачно, заодно получаем номер производства
        if TryStrToint(copy(s,1,pos(' ',s)-1),numpr) then
          if numpr<>0 then begin
            if assigned(progs) then begin //на всякий случай
              //ищем в программах номер производства равный полученному
              //со спецификации
              for i:=0 to progs.Count-1 do
                if (progs[i] as Tprogs).idprv=numpr then begin
                  //номер найден
                  delete(s,1,pos(' ',s)-1);//удаляем номер производства из строки
                  s:=trimLeft(s);          //на всякий случай
                  //собственно добавление куска строки с номером сборки куда надо
                  (progs[i] as Tprogs).idcnststr:=copy(s,1,pos(' ',s)-1);
                  j:=j+1;  //считаем число добавленных номеров
                  //уменьшаем число циклов, надеясь что номер производства один
                  break;
                end;
            end;
          end;
      end;
    end
    else ShowMessage('Это не файл спецификации CADWork');
    closefile(f);
  end;
  //результат чтения файла выводим в сообщении и возвращаем в Result
  if j>0 then begin
    ShowMessage('Присвоение номеров сборки прошло успешно. Присвоено: '+inttostr(j)+' Всего: '+inttostr(progs.Count));
    Result:=true
  end else Result:=False;
end;

procedure Tbtl.prepare;
var i,j,oldcol,newind,oldind,k,z:integer;
    prog,oldprg:Tprogs;   //формируемая программа, старая программа
    exclData:TStringList; //формируемый текст программы
    s,s1,sx,sc:string;
    ok:boolean;
    obrz:TObrs;
begin
  //большой цикл выполняется до тех пор, пока число программ не станет = изделий
  repeat
    ok:=true; //считаем что программ=изделий
    //пробегаем все программы
    for i:=0 to progs.Count-1 do begin
      //проверяем что число изделий в программе больше 1
      if (progs[i] as Tprogs).col>1 then begin
        //так как, такая программа нашлась запрещаем выход из большого цикла
        ok:=false;
        //запоминаем старое количество для корректного формирования номера
        oldcol:=(progs[i] as Tprogs).col;
        //запоминаем старый номер
        oldind:=(progs[i] as Tprogs).idf;
        //полностью копируем старую программу в отдельную переменную
        oldprg:=Tprogs.Create;
        oldprg.idf:=(progs[i] as Tprogs).idf;
        oldprg.col:=(progs[i] as Tprogs).col;
        oldprg.idprv:=(progs[i] as Tprogs).idprv;
        oldprg.optilong:=(progs[i] as Tprogs).optilong;
        oldprg.h:=(progs[i] as Tprogs).h;
        oldprg.sh:=(progs[i] as Tprogs).sh;
        oldprg.zg:=(progs[i] as Tprogs).zg;
        oldprg.long:=(progs[i] as Tprogs).long;
        oldprg.comment:=(progs[i] as Tprogs).comment;
        oldprg.idcnststr:=(progs[i] as Tprogs).idcnststr;
        oldprg.data:=TstringList.Create;
        oldprg.data.Assign((progs[i] as Tprogs).data);
        //трюк не получился, полное копирование
        oldprg.obrs:=TObjectList.Create;
        for k:=0 to (progs[i] as Tprogs).obrs.Count-1 do begin
          obrz:=TObrs.Create;
          obrz.p:=TObrs(TProgs(progs[i]).obrs[k]).p;
          obrz.opkey:=TObrs(TProgs(progs[i]).obrs[k]).opkey;
          obrz.opgr:=TObrs(TProgs(progs[i]).obrs[k]).opgr;
          obrz.side:=TObrs(TProgs(progs[i]).obrs[k]).side;
          obrz.data:=TStringList.Create;
          for z:=0 to TObrs(TProgs(progs[i]).obrs[k]).data.Count-1 do
            obrz.data.Add(TObrs(TProgs(progs[i]).obrs[k]).data.Strings[z]);
          oldprg.obrs.Add(obrz);
        end;
        //
        //удаляем текущую программу из списка
        progs.Delete(i);
        //цикл разделения программ, добавляем отколотые в конец списка
        repeat
          //создаём список строк для новой программы
          exclData:=TStringList.Create;
          //на всякий случай его очищаем
          exclData.Clear;
          //переносим в него текст основной программы
          exclData.Assign((oldprg as Tprogs).data);
          //начинаем исправление текста построчно
          sc:=''; //новый комментарий не получен
          sx:=''; //номер сборки не получен
          for j:=0 to exclData.Count-1 do begin
            s:=exclData[j]; //копируем j-ю строку для проведения действий над ней
            if pos('BT',s)<>0 then begin //ищем в текущей строке номер программы
              //если проход первый, то есть не отнимали количество
              //то новый индекс=старому индексу, иначе новый индекс число
              //программ + 1
              if oldprg.col=oldcol then newind:=oldind
              else newind:=progs.Count+1;
              exclData.Delete(j); //удаляем старую строку
              //и добавляем новую с новым индексом
              exclData.Insert(j,'BT  '+inttostr(newind));
            end;
            //если это строка комментария и номер сборки существует
            //формируем новый комментарий
            if (pos('BN',s)<>0) and (oldprg.idcnststr<>'') then begin
              //получаем в строке sx номер сборки
              //если он не один, то найден будет разделитель
              if pos('/',oldprg.idcnststr)<>0 then
                //и мы копируем номер до первого разделителя
                sx:=copy(oldprg.idcnststr,1,pos('/',oldprg.idcnststr)-1)
              //если он последний то копируем то что осталось  
              else sx:=oldprg.idcnststr;
              //и удаляем его из строки с номерами сборки для текущей программы
              delete(oldprg.idcnststr,1,pos('/',oldprg.idcnststr));
              //формируем новый комментарий в строке sc
              sc:=s+' / '+sx;
              exclData.Delete(j); //удаляем старую строку
              //и добавляем новую с номером сборки+старый комментарий
              exclData.Insert(j,sc);
            end;
            //меняем строку с данными
            if pos('BP',s)<>0 then begin
              //находим в строке количество проходов
              if pos('A:',s)<>0 then begin
                //копируем остаток строки после числа проходов в s1
                s1:=copy(s,pos('A:',s)+5,length(s)-pos(' ',s)+1);
                //новая программа будет одна, добавляем вначало информацию
                s1:='BP A:001'+s1;
                exclData.Delete(j); //удаляем старую строку
                //и добавляем новую с числом изделий в программе =1
                exclData.Insert(j,s1);
                //так как программа читается последовательно, а условие последнее
                //из цикла обработки текста программы выходим
                break;
              end;
            end;
          end; //конец исправления текста программы, новая программа в exclData
          //формируем программу для записи в список программ
          prog:=Tprogs.Create; //создаём новую программу
          prog.idf:=newind; //задаём ей ранее полученный новый индекс
          prog.col:=1; //одно изделие в программе
          prog.idprv:=oldprg.idprv; //номер производства старый
          prog.long:=oldprg.long;   //длинна старая
          prog.zg:=oldprg.zg; //номер заготовки старый
          prog.optilong:=prog.optilong; //длинна заготовки старая
          prog.h:=oldprg.h; //высота заготовки старая
          prog.sh:=oldprg.sh; //ширина заготовки старая
          //трюк вторая часть полное копирование
          prog.obrs:=TObjectList.Create;
          for k:=0 to oldprg.obrs.Count-1 do begin
            obrz:=TObrs.Create;
            obrz.p:=TObrs(oldprg.obrs[k]).p;
            obrz.opkey:=TObrs(oldprg.obrs[k]).opkey;
            obrz.opgr:=TObrs(oldprg.obrs[k]).opgr;
            obrz.side:=TObrs(oldprg.obrs[k]).side;
            obrz.data:=TStringList.Create;
            for z:=0 to TObrs(oldprg.obrs[k]).data.Count-1 do
              obrz.data.Add(TObrs(oldprg.obrs[k]).data.Strings[z]);
            prog.obrs.Add(obrz);
          end;
          //
          //если новый комментарий получен, то указываем его; если нет - старый
          if sc<>'' then begin
            //удаляем служебные символы
            delete(sc,1,3);
            prog.comment:=sc;
          end else prog.comment:=oldprg.comment;
          prog.idcnststr:=sx; //полученный или не полученный номер сборки
          prog.data:=TStringList.Create;
          prog.data.Assign(exclData); //записывается новая полученная программа
          progs.Add(prog); //добавляем в список новую программу
          //уменьшаем на 1 число изделий старой программы
          oldprg.col:=oldprg.col-1;
        until oldprg.col=0; //количество изделий равно 0, все выдернули
        //так как в старой программе не осталось изделий, она нам не нужна
        for k:=0 to oldprg.obrs.Count-1 do TObrs(oldprg.obrs[k]).data.Free;
        oldprg.obrs.Free;
        oldprg.data.Free;
        oldprg.Free;
        //прерываем поиск программ чтобы начать его сначала
        break;
      end; //конец текущей обработки, условия
    end; //конец текущего поиска программы с числом изделий больше 1
  until ok; //количество программ = числу изделий
  //теперь в тексты программ нужно добавить недобавленные номера сборок,
  //если они есть. Проверяем все программы.
  for i:=0 to progs.Count-1 do begin
    //если номер сборки существует
    if (progs[i] as TProgs).idcnststr<>'' then
      //читаем программу
      for j:=0 to (progs[i] as TProgs).data.Count-1 do begin
        s:=(progs[i] as TProgs).data[j];
        //находим строку с комментарием
        if (pos('BN',s)<>0) then
          //если номер сборки не найден в строке комментария
          if pos((progs[i] as TProgs).idcnststr,s)=0 then begin
            //добавляем его к комментарию
            s:=s+' / '+(progs[i] as TProgs).idcnststr;
            (progs[i] as TProgs).data.Delete(j); //удаляем старую строку
            //и добавляем новую с номером сборки+старый комментарий
            (progs[i] as TProgs).data.Insert(j,s);
            //так как мы только исправляем комментарий дальше можно не читать
            //удаляем служебные символы
            delete(s,1,3);
            //обновляем сам комментарий
            (progs[i] as TProgs).comment:=s;
            break;
          end;
      end;
  end;
  ShowMessage('новое число программ '+inttostr(progs.Count));
end; //конец процедуры

procedure TBtl.writeprog(filename:TFileName);
var f:textfile;
    i,j:integer;
begin
  if filename<>'' then begin
    assignfile(f,filename);
    rewrite(f);
    //сначала записываем заголовок
    if assigned(header) then for i:=0 to header.Count-1 do writeln(f,header[i]);
    //теперь перебираем программы
    for i:=0 to progs.Count-1 do
      for j:=0 to (progs[i] as Tprogs).data.Count-1 do
        writeln(f,(progs[i] as Tprogs).data[j]);
    closefile(f);
    ////////////////разделять///////////////////////////
    if Form1.Memo1.Lines.Count>0 then
      Form1.Memo1.Lines.SaveToFile(ExtractFilePath(filename)+'Opti_'+
      ExtractFileName(ChangeFileExt(filename,'.txt')));
    ////////////////////////////////////////////////////
    ShowMessage('программы записаны');
  end;
end;

function sortList(p1,p2:pointer):integer; //служебная функция optimize
begin
  //сортировка по возрастанию
  Result:=sign(Topt(p1).long-Topt(p2).long);
end;

function sortList2(p1,p2:pointer):integer; //служебная функция optimize
begin
  //сортировка по возрастанию
  Result:=sign(Tprogs(p1).zg-Tprogs(p2).zg);
end;

function sortList6(p1,p2:pointer):integer; //служебная функция optimize
var a,b:real;
begin
  //сортировка по возрастанию
  a:=strtofloat(floattostr(Tprogs(p1).optilong)+','+floattostr(Tprogs(p1).zg)+'5');
  b:=strtofloat(floattostr(Tprogs(p2).optilong)+','+floattostr(Tprogs(p2).zg)+'5');
  Result:=sign(b-a);
end;

function sortList3(p1,p2:pointer):integer; //служебная функция optimize
begin
  //сортировка по возрастанию
  Result:=sign(Topt(p1).ostatok-Topt(p2).ostatok);
end;


function sortList4(p1,p2:pointer):integer; //служебная функция optimize
begin
  //сортировка по возрастанию
  Result:=sign(Tolong(p1).l-TOlong(p2).l);
end;

function sortList5(p1,p2:pointer):integer; //служебная функция optimize
begin
  //сортировка по возрастанию
  Result:=sign(Tkart(p1).ostatok-Tkart(p2).ostatok);
end;

function sortList7(p1,p2:pointer):integer; //служебная функция optimize
begin
  //сортировка по убыванию
  Result:=sign(Topt(p2).optilong-Topt(p1).optilong);
end;


procedure Tbtl.nprz(venci:integer);   //процедура пересчёта номеров BTl файла
var i,j,k:integer;
    s,s1,s2,s3:string;
begin
  for i:=0 to progs.Count-1 do begin
    for j:=0 to (progs[i] as TProgs).data.Count-1 do begin
      s:=(progs[i] as TProgs).data[j];
      if pos('BT',s)<>0 then begin
        (progs[i] as TProgs).idf:=i+1;
        s3:='BT '+inttostr(i+1);
        (progs[i] as TProgs).data.Delete(j);
        (progs[i] as TProgs).data.Insert(j,s3);
      end;
      if pos('BN',s)<>0 then begin
        if venci=1 then begin
          s2:=s;
          if pos('_',s2)<>0 then begin
            delete(s2,1,pos('_',s2));
            if pos('/OP@',s2)<>0 then
              delete(s2,pos('/OP@',s2),length(s2)-pos('/OP@',s2)+1);
            s2:=inttostr((progs[i] as TProgs).zg)+'_'+s2;
            (progs[i] as TProgs).comment:=s2;
            s2:='BN '+s2;
            (progs[i] as TProgs).data.Delete(j);
            (progs[i] as TProgs).data.Insert(j,s2);
          end;
        end else if venci=2 then begin
          s2:=inttostr(TProgs(progs[i]).zg)+'_'+inttostr(TProgs(progs[i]).idprv);
          (progs[i] as TProgs).comment:=s2;
          s2:='BN '+s2;
          (progs[i] as TProgs).data.Delete(j);
          (progs[i] as TProgs).data.Insert(j,s2);
        end else begin
          s2:=inttostr((progs[i] as TProgs).zg)+'_'+(progs[i] as TProgs).idcnststr;
          if (progs[i] as TProgs).idcnststr='' then
            s2:=s2+inttostr((progs[i] as TProgs).idprv);
          (progs[i] as TProgs).comment:=s2;
          s2:='BN '+s2;
          (progs[i] as TProgs).data.Delete(j);
          (progs[i] as TProgs).data.Insert(j,s2);
        end;
      end;
      if pos('BP',s)<>0 then
        if pos('P09',s)<>0 then begin
          delete(s,pos('P09',s),length(s)-pos('P09',s)+1);
          s1:=inttostr(i+1);
          for k:=length(s1) to 7 do s1:='0'+s1;
          s:=s+'P09:'+s1;
          (progs[i] as TProgs).data.Delete(j);
          (progs[i] as TProgs).data.Insert(j,s);
          break;
        end;
    end;
    (progs[i] as TProgs).idprv:=i+1;
  end;
end;       //процедура пересчёта номеров BTl файла

//Оптимизация
procedure Tbtl.optimize(a:TObjectList;rez:integer);
var i,z,k,along,j,aai,aaj:integer;
    inlist,outlist,intmplist,outtmplist,karts,tmplist:TObjectList;
    opt:Topt;
    xopt,nnt,nopt:boolean;
    kart:Tkart;
    s:string;
    sum,proc,ostatok,ostatokperc,alllong:real;
    nn:array of integer;

//функция полного копирования списков TObjectList > new TObjectList
//с созданием объектов
function listCopy(b:TObjectList):TObjectList;
var copt:TOpt;
    ai:integer;
begin
  if assigned(b) then begin
    Result:=TObjectList.Create;
    for ai:=0 to b.Count-1 do begin
      copt:=TOpt.Create;
      copt.id:=TOpt(b[ai]).id;
      copt.long:=TOpt(b[ai]).long;
      copt.idbrev:=TOpt(b[ai]).idbrev;
      copt.ostatok:=TOpt(b[ai]).ostatok;
      copt.optilong:=TOpt(b[ai]).optilong;
      Result.Add(copt);
    end;
  end else Result:=nil;
end;

//функция добавления элементов списков TObjectList add new TObjectList
//с созданием объектов
procedure listadd(b:TObjectList;c:TObjectList);
var ai:integer;
    copt:TOpt;
begin
  if assigned(b) then begin
    if not assigned(c) then c:=TObjectList.Create;
    for ai:=0 to b.Count-1 do begin
      copt:=TOpt.Create;
      copt.id:=TOpt(b[ai]).id;
      copt.long:=TOpt(b[ai]).long;
      copt.idbrev:=TOpt(b[ai]).idbrev;
      copt.ostatok:=TOpt(b[ai]).ostatok;
      copt.optilong:=TOpt(b[ai]).optilong;
      c.Add(copt);
    end;
  end;
end;

//тело основной процедуры оптимизации
begin
  //если есть хоть одна раскраиваемая заготовка и хотя бы одна деталь
  //выполняем основной код процедуры
  if (a.Count>0) and (progs.Count>0) then begin
    //создаём входной список
    inlist:=TObjectList.Create;
    //закидываем в него все нужные данные
    for i:=0 to progs.Count-1 do begin
      opt:=Topt.Create;
      opt.id:=TProgs(progs[i]).idf;
      opt.long:=TProgs(progs[i]).long;
      inlist.Add(opt);
    end;
    //сортируем входной список по возрастанию
    inlist.Sort(sortList);
    //сортируем список заготовок по возрастанию
    a.Sort(sortList4);
    //создаём выходной список
    outlist:=TObjectList.Create;
    //условие успешной оптимизации, max длинна заготовки + ширина реза
    //>= максимальная длинна изделия
    if (TOpt(inlist[inlist.Count-1]).long+rez)<=Tolong(a[a.Count-1]).l then
    begin
      //текущий номер изделия
      k:=0;
      //начинаем оптимизацию, пока изделия во входном листе не кончатся
      repeat
        //номер раскраиваемой заготовки +1
        k:=k+1;
        //считаем что ни одной заготовки не раскроилось
        nopt:=true;
        //создаём список карт
        karts:=TObjectlist.Create;
        //бежим с конца массива заготовок до начала
        for i:=a.Count-1 downto 0 do begin
          //если максимальное изделие входного списка+рез меньше
          //раскраиваемого изделия
          //проверяем что число заготовок <>0
          if (Tolong(a[i]).l>=(Topt(inlist[inlist.Count-1]).long+rez))
          and (Tolong(a[i]).opticol<>0) then begin
            //заготовка раскраивается
            nopt:=false;
            //оптимальная длинна заготовки = текущая со списка заготовок
            along:=Tolong(a[i]).l;
            //создаём временный входной список для работы
            intmplist:=TObjectList.Create;
            //копируем входной список во временный входной
            intmplist:=listcopy(inlist);
            //создаём временный выходной список
            outtmplist:=TObjectList.Create;
            repeat
              //считаем что нельзя отнять изделие от заготовки
              xopt:=true;
              //пробегаем временный входной список с конца до начала
              for j:=intmplist.Count-1 downto 0 do begin
                //если от текущей длинны изделия отнимается j-ая заготовка
                if (along-Topt(intmplist[j]).long-rez)>=0 then begin
                  //отнимаем если отнимается учитывая ширину реза
                  along:=along-Topt(intmplist[j]).long-rez;
                  //изделие смогли отнять, запрещаем выход из цикла
                  xopt:=false;
                  //создаём переменную изделия
                  opt:=Topt.Create;
                  opt.id:=Topt(intmplist[j]).id;
                  opt.long:=Topt(intmplist[j]).long;
                  opt.idbrev:=k;    //номер бревна присваиваем k
                  opt.ostatok:=along; //текущий остаток
                  opt.optilong:=Tolong(a[i]).l; //заготовка i
                  //закидываем изделие во временный выходной список
                  outtmplist.Add(opt);
                  //и удаляем его из временного входного списка
                  intmplist.Delete(j);
                end;
              end;
            //изделие от заготовки уже не отнимается
            until xopt;
            //создаём текущую карту
            kart:=Tkart.Create;
            //остаток после цикла в карту
            kart.ostatok:=along;
            kart.optilong:=Tolong(a[i]).l; //заготовка i
            //входной временный список в текущую карту
            kart.inl:=TObjectList.Create;
            kart.inl.Assign(intmplist);
            //выходной временный список в текущую карту
            kart.oul:=TObjectList.Create;
            kart.oul.Assign(outtmplist);
            //текущую карту в список карт
            karts.Add(kart);
          //останавливаем цикл хода по заготовкам
          end; // else break;
        //заготовки пройдены
        end;
        //Если карты сгенерировались
        if karts.Count>0 then begin
          //карты получены сортируем их по возрастанию остатка
          karts.Sort(sortList5);
          //нулевая карта содержит минимальный остаток
          for z:=0 to a.Count-1 do
            if Tolong(a[z]).l=Tkart(karts[0]).optilong then begin
              Tolong(a[z]).col:=Tolong(a[z]).col+1;
              //-1 признак бесконечного числа заготовок, если они конечны
              //отнимаем от общего числа одну заготовку
              if Tolong(a[z]).opticol<>-1 then
                Tolong(a[z]).opticol:=Tolong(a[z]).opticol-1;
            end;
          //входной лист 0-ой карты становится входным листом, а выходной выходным
          inlist.Free;
          inlist:=TObjectList.Create;
          inlist:=listcopy(Tkart(karts[0]).inl);
          listadd(Tkart(karts[0]).oul,outlist);
          //убиваем список карт и списки внутри него
          for z:=karts.Count-1 to 0 do begin
            Tkart(karts[z]).inl.Free;
            Tkart(karts[z]).oul.Free;
          end;
          karts.Free;
        end;
      //оптимизация закончена, изделий во входном списке не осталось
      //или заготовки больше не раскраиваются
      until (inlist.Count=0) or nopt;
    end else ShowMessage('длинна max изделия больше чем max заготовка');
    if nopt then ShowMessage('Внимание! В раскрой попали не все изделия!'+
    ' Измените число исходных заготовок');
    ////////////////////////////////////////////////////////////
    Form1.Memo1.Clear;
    //сортируем выходной список по длинне
    outlist.Sort(sortlist7);
    //инициализируем массив нулевым элементом=0
    setlength(nn,1);
    nn[0]:=0;
    //вычисляем новые номера заготовок, добавляем номера производства по порядку
    for aai:=0 to outlist.Count-1 do begin
      //номер заготовки не найден в массиве новых номеров
      nnt:=true;
      //проверяем весь массив
      for aaj:=0 to length(nn)-1 do if Topt(outlist[aai]).idbrev=nn[aaj] then nnt:=false;
      //если номер заготовки не найден, добавляем его новым элементом
      if nnt then begin
        setlength(nn,length(nn)+1);
        nn[length(nn)-1]:=Topt(outlist[aai]).idbrev;
      end;
    end;
    //меняем номера заготовок на новые
    for aai:=0 to outlist.Count-1 do
      for aaj:=1 to length(nn)-1 do
        //берём список изделий ищем номер заготовки в массиве номеров заготовок
        if Topt(outlist[aai]).idbrev=nn[aaj] then begin
          //как только он найден присваиваем его индекс, это и будет новый номер
          Topt(outlist[aai]).idbrev:=aaj;
          //номера уникальны, зачем искать дальше
          break;
    end;
    {for aai:=1 to length(nn)-1 do Form1.Memo1.Lines.Add(inttostr(aai)+'='+inttostr(nn[aai]));
      for i:=0 to outlist.Count-1 do begin
      s:='';
      s:=s+inttostr(Topt(outlist[i]).id)+' / ';
      s:=s+inttostr(Topt(outlist[i]).idbrev)+' / ';
      s:=s+inttostr(Topt(outlist[i]).long)+' / ';
      s:=s+inttostr(Topt(outlist[i]).optilong)+' / ';
      s:=s+inttostr(Topt(outlist[i]).ostatok)+' / ';
      Form1.Memo1.Lines.Add(s);
    end;}
    ////////////////////////////////////////////////////////////
    //теперь нужно видоизменить основной объект с программами
    //перебираем выходной список сначала до конца
    for i:=0 to outlist.Count-1 do begin
      //ищем совпадение id списка, со списком программ
      for k:=0 to progs.Count-1 do begin
        if Topt(outlist[i]).id=(progs[k] as Tprogs).idf then begin
          //если уже оптимизировали удаляем старый комментарий
          if pos('/OP@',(progs[k] as Tprogs).comment) <>0 then
            delete((progs[k] as Tprogs).comment,
            pos('/OP@',(progs[k] as Tprogs).comment),
            length((progs[k] as Tprogs).comment)-
            pos('/OP@',(progs[k] as Tprogs).comment)+1);
          //записываем номер заготовки и её длинну
          (progs[k] as Tprogs).zg:=TOpt(outlist[i]).idbrev;
          (progs[k] as Tprogs).optilong:=TOpt(outlist[i]).optilong;
          //записываем новый комментарий
          (progs[k] as Tprogs).comment:=(progs[k] as Tprogs).comment+
          '/OP@ заготовка: '+inttostr(Topt(outlist[i]).idbrev)+
          ' /длинна: '+floattostr(Topt(outlist[i]).optilong/10)+
          ' /остаток: '+floattostr(Topt(outlist[i]).ostatok/10);
          //ищем комментарий в тексте программы
          for j:=0 to (progs[k] as Tprogs).data.Count-1 do begin
            //найдена строка с комментарием
            if pos('BN',(progs[k] as Tprogs).data[j])<>0 then begin
              s:=(progs[k] as Tprogs).data[j];
              delete(s,1,3); //удаляем служебные символы
              trimLeft(s);   //на случай лишнего пробела
              //если комментарий в тексте <> комментарию в объекте программы
              if s<>(progs[k] as Tprogs).comment then begin
                //берём его из программы и добавляем служебные символы
                s:='BN '+(progs[k] as Tprogs).comment;
                //удаляем j-ю строку со старым комментарием
                (progs[k] as Tprogs).data.Delete(j);
                //вставляем j-ю строку с новым комментарием
                (progs[k] as Tprogs).data.Insert(j,s);
              end;
            end;
          end;
        end;
      end;
    end;
    /////////////нужно разделять////////////////////////////////////
  //  Form1.Memo1.Clear;
  //  j:=Topt(outlist[outlist.Count-1]).idbrev;
    j:=length(nn)-1;
    k:=0;
    ostatok:=0;
    alllong:=0;
    ostatokperc:=0;
    repeat
      k:=k+1;
      tmplist:=TObjectList.Create;
      for i:=0 to outlist.Count-1 do begin
        if Topt(outlist[i]).idbrev=k then begin
          opt:=Topt.Create;
          opt.id:=Topt(outlist[i]).id;
          opt.long:=Topt(outlist[i]).long;
          opt.idbrev:=Topt(outlist[i]).idbrev;  //номер заготовки
          opt.ostatok:=Topt(outlist[i]).ostatok;
          opt.optilong:=Topt(outlist[i]).optilong;
          tmplist.Add(opt);
        end;
      end;
      tmplist.Sort(sortList3);
      s:=''; sum:=0;
      for i:=0 to tmplist.Count-1 do begin
        sum:=sum+Topt(tmplist[i]).long/10;
        if rez>0 then sum:=sum+(rez/10);
        s:=s+' | '+inttostr(Topt(tmplist[i]).id)+', L='+floattostr(Topt(tmplist[i]).long/10);
      //    Form1.Memo1.Lines.Add(floattostr(Topt(tmplist[i]).ostatok/10));
      end;
      ostatok:=ostatok+Topt(tmplist[0]).ostatok;
      alllong:=alllong+Topt(tmplist[0]).optilong;
      ostatokperc:=(ostatok/alllong)*100;
      proc:=(Topt(tmplist[0]).ostatok/Topt(tmplist[0]).optilong)*100;
      s:='№ '+inttostr(k)+s+' /заготовка: '+floattostr(Topt(tmplist[0]).optilong/10)+
      ' /длинна: '+floattostr(sum)+
      '  /остаток: '+floattostr(Topt(tmplist[0]).ostatok/10)
      +' /отход: '+floattostrF(proc,ffFixed,8,3)+' %';
      Form1.Memo1.Lines.Add(s);
      tmplist.Free;
    until k=j;
    //вывод общего количества заготовок
    s:='';
    for z:=0 to a.Count-1 do
      if Tolong(a[z]).col>0 then s:=s+' заготовка '+floattostr(Tolong(a[z]).l/10)+
      ' шт: '+inttostr(Tolong(a[z]).col)+';';
    Form1.Memo1.Lines.Add('');
    s:=s+' остаток: '+floattostr(ostatok/10)+';'+' Общая длинна: '+
    floattostr(alllong/10)+'; остаток: '+floattostrF(ostatokperc,ffFixed,8,3)+'%';
    Form1.Memo1.Lines.Add(s);
    //сортируем список по возрастанию, относительно номера заготовки и её длинны
    progs.Sort(sortList2);
 //   progs.Sort(sortList6);
    //убиваем созданные объекты
    outlist.Free;
    inlist.Free;
  end; //нечего раскраивать или нет деталей на раскрой
end;


procedure TBtl.writeXprog(ax:integer;filename:TFileName);
var f:textfile;
    i:integer;
begin
  if filename<>'' then begin
    assignfile(f,filename);
    rewrite(f);
    //сначала записываем заголовок
    if assigned(header) then for i:=0 to header.Count-1 do writeln(f,header[i]);
    //теперь записываем полученную в параметре программу
    for i:=0 to (progs[ax-1] as Tprogs).data.Count-1 do
        writeln(f,(progs[ax-1] as Tprogs).data[i]);
    closefile(f);
    ////////////////////////////////////////////////////
    ShowMessage('программы записаны');
  end;
end;


procedure TBtl.load(filename:TFileName);
var f:textfile;
    s,s1,s2,s3,s4,s5:string;
    prog:TProgs;
    oprt,i,oldzg,newzg:integer;
    obr:Tobrs;
    eop:boolean;
begin
  if filename<>''  then begin
    assignfile(f,filename);
    oldzg:=0; newzg:=0;
    reset(f);
    readln(f,s);
    if ((pos('VN',s)=1) and (pos('BTL V5.0',s)<>0))// or (pos('BTL V1.0',s)<>0)
     then begin
      //header:=TStringList.Create;
      //заполняем заголовок до тех пор, пока не найдена первая программа
      repeat
        //header.Add(s);
        readln(f,s);
      until (pos('BT',s)=1) or eof(f);
      eop:=false;
      //если первая программа найдена создаём список программ
      //подтверждаем полное удаление объекта из памяти
      //if pos('BT',s)=1 then progs:=TObjectList.Create(true);
      while not eof(f) do begin  //читаем файл полностью
        //читаем пока не нашли новую программу или файл не кончился
        repeat
          if pos('BT',s)=1 then begin  //мы нашли номер программы
            prog:=TProgs.Create;       //создаём объект программы
            prog.sorted:=false;        //операции программы не отсортированы
            prog.data:=TStringList.Create; //создаём список текста программы
            s1:=s;      //теперь работаем с s1
            oprt:=0;    //список операций = 0
            delete(s1,1,3);
            if assigned(progs) then
              prog.idf:=progs.Count+1
            else prog.idf:=strtoint(s1);    //номер закидываем в объект программы
            eop:=false;
          end;
          if pos('BN',s)=1 then begin //мы нашли строчку комментария программы
            s1:=s;
            delete(s1,1,3);
            if assigned(prog) then    //если программа создана
               prog.comment:=s1;      //кидаем в комментарий
          end;
          if pos('BP',s)=1 then begin //если строка с данными программы
            s1:=s;
            if pos('A:',s1)<>0 then begin  //ищем в строке количество проходов
              delete(s1,1,pos('A:',s1)+1);
              delete(s1,pos(' ',s1),length(s1)-pos(' ',s1)+1); //выделяем число
              if assigned(prog) then
                  prog.col:=strtoint(s1);  //число проходов
            end;
            s1:=s;                         //восстанавливаем строку
            if pos('P01',s1)<>0 then begin //ищем длинну
              delete(s1,1,pos('P01',s1)+3);
              delete(s1,pos(' ',s1),length(s1)-pos(' ',s1)+1);
              if assigned(prog) then
                  prog.long:=strtoint(s1);
            end;
            s1:=s;
            if pos('P02',s1)<>0 then begin  //ищем высоту бруса
              delete(s1,1,pos('P02',s1)+3);
              delete(s1,pos(' ',s1),length(s1)-pos(' ',s1)+1);
              if assigned(prog) then
                  prog.h:=strtoint(s1);
            end;
            s1:=s;
            if pos('P03',s1)<>0 then begin  //ищем ширину бруса
              delete(s1,1,pos('P03',s1)+3);
              delete(s1,pos(' ',s1),length(s1)-pos(' ',s1)+1);
              if assigned(prog) then
                  prog.sh:=strtoint(s1);
            end;
            s1:=s;
            if pos('P09',s1)<>0 then begin  //ищем номер производства
              delete(s1,1,pos('P09',s1)+3);
              delete(s1,pos(' ',s1),length(s1)-pos(' ',s1)+1);
              if assigned(prog) then
                  prog.idprv:=strtoint(s1);
            end;
          end;   //строка с данными распарсена
          //найдена операция
          if pos('KS',s)=1 then begin
            //если это первая операция в программе создаём список операций
            if oprt=0 then prog.obrs:=TObjectList.Create;
            oprt:=oprt+1;
            eop:=true; //найдена операция
            //создаём текущую операцию
            obr:=TObrs.Create;
            obr.data:=TStringList.Create;
            s1:=s;
            delete(s1,1,3);
            s1:=copy(s1,1,pos('-',s1)-1);
            obr.opgr:=strtoint(s1);
            s1:=s;
            delete(s1,1,pos('-',s1));
            s1:=copy(s1,1,pos('-',s1)-1);
            obr.opkey:=strtoint(s1);
            s1:=s;
            delete(s1,1,5);
            s1:=copy(s1,pos('-',s1)+1,1);
            obr.side:=strtoint(s1);
            obr.data.Add(s);
            //инициализация массива параметров с помощью отриц.чисел - пустое значение
            for i:=1 to 21 do obr.p[i]:=-1;
          end;
          if pos('KP',s)=1 then begin
            if oprt<>0 then begin
              s1:=s;
              delete(s1,1,3);
              repeat
                s2:=copy(s1,2,2); //индекс массива - он же номер параметра
                delete(s1,1,4);
                //значение параметра
                if length(s1)>8 then s3:=copy(s1,1,pos(' ',s1)-1)
                  else s3:=s1;
                if length(s1)>8 then delete(s1,1,pos(' ',s1)) else s1:='';
                //добавляем параметр в массив
                if pos('-',s3)<>0 then begin
                  delete(s3,pos('-',s3),1);
                  obr.p[21]:=strtoint(s2);
                end;
                obr.p[strtoint(s2)]:=strtoint(s3);
              until s1='';
              obr.data.Add(s);
            end;
          end;
          if pos('KF',s)=1 then begin
            if oprt<>0 then begin
              obr.data.Add(s);
            end;
          end;
          //добавление операции в  программу
          if (pos('KF FR',s)=1) and (oprt<>0) and assigned(prog.obrs) then begin
            prog.obrs.Add(obr);
            eop:=false; //операция добавлена
          end;
          //добавляем текущую прочитанную строку в блок данных
          if assigned(prog) then
                prog.data.Add(s);
          readln(f,s); //читаем новую строку
          //последняя строка данных
          if eof(f) then begin
            //добавим её к данным программы
            if assigned(prog) then prog.data.Add(s);
            //если в этой строке конец операции добавляем и операцию
            if (pos('KF',s)=1) and (oprt<>0) and assigned(prog.obrs) then
              prog.obrs.Add(obr);
          end;
          //если мы нашли новую программу или новую операцию, а старую не добавили
          if ((pos('BT',s)=1) or (pos('KS',s)=1)) and eop and assigned(prog.obrs) then begin
            prog.obrs.Add(obr);
            eop:=false;
          end;
        //если в прочитанной строке новая программа или конец файла в верхний цикл
        until (pos('BT',s)=1) or eof(f);
        //если есть список кидаем туда программу
        if assigned(progs) then begin
             if oldzg=0 then begin
               s5:=TProgs(progs[progs.Count-1]).comment;
               s4:=copy(s5,1,pos('_',s5)-1);
               if not trystrtoint(s4,oldzg) then oldzg:=-1;
             end;
             if oldzg>0 then begin
               s4:=copy(prog.comment,1,pos('_',prog.comment)-1);
               if not trystrtoint(s4,newzg) then newzg:=-1;
               if newzg>0 then begin
                 delete(prog.comment,1,pos('_',prog.comment)-1);
                 prog.comment:=inttostr(oldzg+newzg)+prog.comment;
                 prog.reprog;
               end;
             end;
             progs.Add(prog);
        end;
      end;
    end else showmessage('Это не BTL-файл версии 5.0');
    closefile(f); //файл кончился, закрываем его
  end;
end;

/////////////////интерфейсня часть///////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////


procedure TForm1.listprog;
var li:TListItem;
    i:integer;
begin
  ListView1.Clear;
  if assigned(Btl) and assigned(btl.progs) then
    for i:=0 to btl.progs.Count-1 do begin
      li:=listView1.Items.Add;
      li.Caption:=inttostr((btl.progs[i] as Tprogs).idf);
      li.SubItems.Add(inttostr((btl.progs[i] as Tprogs).col));
      li.SubItems.Add(inttostr((btl.progs[i] as Tprogs).idprv));
      li.SubItems.Add(floattostr((btl.progs[i] as Tprogs).long/10));
      li.SubItems.Add((btl.progs[i] as Tprogs).comment);
      li.SubItems.Add((btl.progs[i] as Tprogs).idcnststr);
      if (btl.progs[i] as Tprogs).zg<>0 then
      li.SubItems.Add(inttostr((btl.progs[i] as Tprogs).zg));
    end;
end;

procedure TForm1.N3Click(Sender: TObject);
var i:integer;
begin
    if assigned(btl) then  begin
    if assigned(Btl.progs) then begin
      if Btl.progs.Count>0 then
      for i:=0 to Btl.progs.Count-1 do
        if assigned(TProgs(Btl.progs[i]).data) then begin
          TProgs(Btl.progs[i]).data.Free;
          if assigned(TProgs(btl.progs[i]).obrs)
            then TProgs(btl.progs[i]).obrs.Free;
        end;
      Btl.header.Free;
      Btl.progs.Free;
    end;
    Btl.Free;
  end;
  Application.Terminate;
end;

procedure TForm1.Button2Click(Sender: TObject);
begin
  N3Click(self);
end;

procedure TForm1.N2Click(Sender: TObject);
begin
  if OpenDialog1.Execute then   //если файл открыт создаём объект
        Btl:=TBtl.Create(OpenDialog1.FileName);
  //если программы загрузились читаем их количество
  if assigned(Btl) then
  if assigned(Btl.progs) then begin
     Label2.Caption:=inttostr(Btl.progs.Count);
     listprog;
     if Btl.progs.Count>0 then begin
       N4.Enabled:=True;
       N24.Enabled:=true;
       N20.Enabled:=true;
       N11.Enabled:=true;
       Cadwork1.Enabled:=true;
       N7.Enabled:=true;
       N22.Enabled:=true;
       // N8.Enabled:=false;
       CadWork1.Enabled:=true;
       //Button3.Enabled:=false;
     end;
   end else begin
     Label2.Caption:='0';
     N4.Enabled:=False;
  end;
end;

procedure TForm1.Button1Click(Sender: TObject);
begin
  N2Click(self);
end;

procedure TForm1.N5Click(Sender: TObject);
begin
  Form2.Show;
end;

procedure TForm1.BTL1Click(Sender: TObject);
begin
  Form3.Show;
end;

procedure TForm1.CadWork1Click(Sender: TObject);
begin
  if (OpenDialog2.Execute) and (assigned(Btl)) and (assigned(Btl.progs)) then
  begin
    if not Btl.attachCADWorkSpec(OpenDialog2.FileName) then
        ShowMessage('Спецификация CADWork загрузилась неудачно')
    else listprog;    
  end;
end;

procedure TForm1.N6Click(Sender: TObject);
begin
  Btl.prepare;
  N8.Enabled:=true;
  CadWork1.Enabled:=false;
  Button3.Enabled:=true;
  listprog;
end;

procedure TForm1.N7Click(Sender: TObject);
begin
  if SaveDialog1.Execute then Btl.writeprog(SaveDialog1.FileName);
end;

procedure TForm1.N8Click(Sender: TObject);
var xrez,i,x:integer;
    olong:TObjectList;
    xlong:TOlong;
begin
   if assigned(Btl) and (ListView2.Items.Count>0) then begin
    if Edit3.Text<>'' then if not TryStrToInt(edit3.Text,xrez) then xrez:=0;
    xrez:=xrez*10;
    olong:=TObjectList.Create;
    for i:=0 to ListView2.Items.Count-1 do
      if ListView2.Items[i].Checked then begin
        x:=StrToInt(ListView2.Items[i].Caption)*10;
        xlong:=TOlong.Create;
        xlong.l:=x;
        xlong.col:=0;
        if ListView2.Items[i].SubItems[0]<>'' then begin
          if not TryStrToInt(ListView2.Items[i].SubItems[0],xlong.opticol) then
            ShowMessage('Неправильно введено количество заготовок')
        end else xlong.opticol:=-1;
        olong.Add(xlong);
      end;
    if olong.Count>0 then begin Btl.prepare; Btl.optimize(olong,xrez); listprog; end;
    olong.Free;
  end;
end;

procedure TForm1.Button3Click(Sender: TObject);
begin
  N8Click(self);
end;

procedure TForm1.N9Click(Sender: TObject);
begin
  Btl.nprz(0);
  listprog;
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  Form1.readlong;
end;

procedure TForm1.readlong;
var f:textfile;
    s:string;
    li:TlistItem;
    i:integer;
    dob:boolean;
begin
  assignfile(f,'optilong.txt');
  if FileExists('optilong.txt') then begin
    reset(f);
    while not eof(f) do begin
      readln(f,s);
      dob:=true;
      for i:=0 to ListView2.Items.Count-1 do
        if pos(s,ListView2.Items[i].Caption)<>0 then dob:=false;
      if dob then begin
        li:=ListView2.Items.Add;
        li.Caption:=s;
        li.SubItems.Add('');
      end;
    end;
    closefile(f);
  end;

end;

procedure TForm1.BitBtn2Click(Sender: TObject);
var s:string;
    f:TStringList;
    i:integer;
begin
  if assigned(ListView2.Selected) then begin
    s:=ListView2.Selected.Caption;
    f:=TStringList.Create;
    if FileExists('optilong.txt') then f.LoadFromFile('optilong.txt');
    if f.Count>0 then for i:=0 to f.Count-1 do
      if pos(s,f[i])<>0 then begin f.Delete(i); break; end;
    f.SaveToFile('optilong.txt');
    f.Free;
    ListView2.Selected.Free;
  end;
end;

procedure TForm1.BitBtn1Click(Sender: TObject);
begin
  Form4.ShowModal;
end;



procedure TForm1.FormCloseQuery(Sender: TObject; var CanClose: Boolean);
var i:integer;
begin
  if assigned(btl) then  begin
    if assigned(Btl.progs) then begin
      if Btl.progs.Count>0 then
      for i:=0 to Btl.progs.Count-1 do
        if assigned(TProgs(Btl.progs[i]).data) then begin
          TProgs(Btl.progs[i]).data.Free;
          if assigned(TProgs(btl.progs[i]).obrs)
            then TProgs(btl.progs[i]).obrs.Free;
        end;
      Btl.header.Free;
      Btl.progs.Free;
    end;
    Btl.Free;
  end;
end;

procedure TForm1.N10Click(Sender: TObject);
begin
  Btl.nprz(1);
  listprog;
end;

procedure TForm1.ListView2MouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  R:TRect;
  ht:TLVHitTestInfo;
begin
  //добавление редактируемого поля в ListView2
  Item := ListView2.GetItemAt(2, Y);
  if Item=nil then Exit;
  FillChar(ht,SizeOf(ht),0);
  ht.pt.x:=X;
  ht.pt.y:=Y;
  SendMessage(ListView2.Handle, LVM_SUBITEMHITTEST, 0, Integer(@ht));
  Sub:=ht.iSubItem;
  //Caption:=inttostr(sub);
  if Sub > 0 then begin
    ListView_GetSubItemRect(ListView2.Handle, Item.Index, Sub,LVIR_BOUNDS, @R);
    Offsetrect(R,ListView1.Left,ListView2.Top);
    Edit1.SetBounds(R.Left,R.Top,R.Right-R.Left,R.Bottom-R.Top);
    Dec(Sub);
    Edit1.Text:=Item.SubItems[Sub];
    Edit1.Visible:=True;
  end;
end;

procedure TForm1.Edit1KeyPress(Sender: TObject; var Key: Char);
begin
  if Key=#13 then begin
    Item.SubItems[Sub]:=Edit1.Text;
    Edit1.Visible:=False;
  end;
end;

procedure TForm1.N12Click(Sender: TObject);
begin
  Form5.ShowModal;
end;

procedure TForm1.N14Click(Sender: TObject);
begin
  ShowMessage('Программа для работы с BTL-файлами (программами станков) версии'
  +' 5.0 <формат CadWork> '+#10#13+
  'Владислав Никитин, ООО "Кадрин Строй Комплект" 2019 год.'+#10#13
  +'+79231621108'+#10#13+'kadrinstk@yandex.ru'+#10#13+'bubaeshka@yandex.ru');
end;

procedure TForm1.N15Click(Sender: TObject);
var i,h:integer;
    fs:boolean;
begin
  if assigned(Btl) then if assigned(btl.progs) then if btl.progs.Count>0 then
  begin
    h:=TProgs(Btl.progs[0]).h;
    fs:=true;
    for i:=0 to btl.progs.Count-1 do if TProgs(Btl.progs[i]).h<>h then begin
      ShowMessage('Ошибка! Файл содержит разную высоту изделий!');
      fs:=false;
      Break;
    end;
    if fs then Form6.Show;
  end;
end;

procedure TForm1.N16Click(Sender: TObject);
var i:integer;
begin
  if assigned(Btl) then if assigned(btl.progs) then if btl.progs.Count>0 then
  begin
    for i:=0 to btl.progs.Count-1 do
      TProgs(btl.progs[i]).perestanovka;
    ShowMessage('перестановка выполнена успешно!');
  end;
end;

procedure TForm1.N17Click(Sender: TObject);
begin
  Btl.nprz(2);
  listprog;
end;

procedure TForm1.N18Click(Sender: TObject);
var i:integer;
begin
  if assigned(Btl) then if assigned(Btl.progs) then if Btl.progs.Count>0 then
  for i:=0 to btl.progs.Count-1 do TProgs(Btl.progs[i]).changesidecut;
  ShowMessage('Операции изменены');
end;

procedure TForm1.N19Click(Sender: TObject);
begin
  perestavka(1,false);
end;

procedure TForm1.N21Click(Sender: TObject);
begin
  Form7.Show;
end;

procedure TForm1.Button4Click(Sender: TObject);
begin
  N7Click(self);  
end;

procedure TForm1.N22Click(Sender: TObject);
begin
  Form8.Show;
end;

procedure TForm1.N23Click(Sender: TObject);
begin
  Form9.Show;
end;

procedure TForm1.N25Click(Sender: TObject);
begin
  perestavka(2,false);
end;

procedure TForm1.N26Click(Sender: TObject);
var i,pr_count:integer;
begin
  if assigned(Btl) then if assigned(Btl.progs) then
    if Btl.progs.Count>0 then begin
      pr_count:=0;
      for i:=0 to Btl.progs.Count-1 do begin
        pr_count:=pr_count+TProgs(Btl.progs[i]).removebadcut;
      end;
      ShowMessage('удалено '+inttostr(pr_count)+' операций в '+inttostr(Btl.progs.Count)+' программах');
  end;
end;

procedure TForm1.perestavka(cases:byte;polubrus:boolean);
var i,zy:integer;
    uopok,uopcancel:boolean; //упорядочивать ли операции?
begin
  if assigned(Btl) then if assigned(btl.progs) then if btl.progs.Count>0 then
  begin
    zy:=0;
    uopok:=false;
    uopcancel:=false;
    for i:=0 to btl.progs.Count-1 do begin
      //текущая программа отсортирована?
      if not TProgs(btl.progs[i]).sorted then
        //если не отсортирована, пользователь сказал сортировать?
        //если сказал, то сортируем
        if uopok then TProgs(btl.progs[i]).changesidecut else
          //если не сказал сортировать выдаём запрос на сортировку, если запрос не отменён
          if not uopcancel then
            case messagebox(self.Handle,PChar('Стало известно что, операции не упорядочены, упорядочить?'),
                 PChar('Вы уверены?'),MB_OKCANCEL) of
              IDOK: begin TProgs(btl.progs[i]).changesidecut; uopok:=true; end;
              IDCANCEL: uopcancel:=true;
            end;
      //меняем местами чашки, подсчитываем количество изменений.
      zy:=zy+TProgs(btl.progs[i]).perestanovkaCadWork(cases,polubrus);
    end;
    ShowMessage('перестановка выполнена успешно! Пересчитано чашек '+inttostr(zy));
  end;

end;

procedure TForm1.N27Click(Sender: TObject);
begin
  perestavka(1,true);
end;

procedure TForm1.N28Click(Sender: TObject);
begin
  perestavka(2,true);
end;

procedure TForm1.CheckBox1Click(Sender: TObject);
var i:integer;
begin
  if CheckBox1.Checked then begin
      for i:=0 to ListView2.Items.Count-1 do
         ListView2.Items[i].Checked:=true;
    end else begin
      for i:=0 to ListView2.Items.Count-1 do
        ListView2.Items[i].Checked:=false;
  end;
end;

procedure TForm1.N29Click(Sender: TObject);
begin
  if OpenDialog1.Execute then if assigned(Btl) then begin
    Btl.load(OpenDialog1.FileName);
    if assigned(Btl.progs) then begin
      Label2.Caption:=inttostr(Btl.progs.Count);
      listprog;
    end;  
  end;    
end;

procedure TForm1.N30Click(Sender: TObject);
var fff:textfile;
    i:integer;
begin
  if SaveDialog2.Execute then begin
    if (SaveDialog2.FileName<>'') and assigned(Btl) and assigned(Btl.progs) and (Btl.progs.Count>0) then begin
      assignfile(fff,SaveDialog2.FileName);
      rewrite(fff);
      for i:=0 to Btl.progs.Count-1 do writeln(fff,TProgs(Btl.progs[i]).comment);
      closefile(fff);
    end;
  end;
end;

end.
